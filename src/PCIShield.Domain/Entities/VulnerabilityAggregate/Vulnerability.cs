using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using Microsoft.EntityFrameworkCore;
using System.Linq;
using Ardalis.GuardClauses;
using System.Collections.Immutable;
using System.Text.Json;
using LanguageExt;
using static LanguageExt.Prelude;
using PCIShield.Domain.Exceptions;
using PCIShield.Domain.Events;
using PCIShieldLib.SharedKernel;
using PCIShieldLib.SharedKernel.Interfaces;

namespace PCIShield.Domain.Entities
{
    
    public class Vulnerability : BaseEntityEv<Guid>, IAggregateRoot, ITrackedEntity, ITenantEntity
    {
        [Key]
        public Guid VulnerabilityId { get; private set; }
        
        public Guid TenantId { get; private set; }
        
        public string VulnerabilityCode { get; private set; }
        
        public string? CVEId { get; private set; }
        
        public string Title { get; private set; }
        
        public int Severity { get; private set; }
        
        public decimal? CVSS { get; private set; }
        
        public DateTime DetectedDate { get; private set; }
        
        public DateTime? ResolvedDate { get; private set; }
        
        public int Rank { get; private set; }
        
        public DateTime CreatedAt { get; private set; }
        
        public Guid CreatedBy { get; private set; }
        
        public DateTime? UpdatedAt { get; private set; }
        
        public Guid? UpdatedBy { get; private set; }
        
        public bool IsDeleted { get; private set; }
        
        public void SetTenantId(Guid tenantId)
        {
            TenantId = Guard.Against.Default(tenantId, nameof(tenantId));
        }
        public void SetAssetId(Guid assetId)
        {
            AssetId = Guard.Against.Default(assetId, nameof(assetId));
        }
        public void SetVulnerabilityCode(string vulnerabilityCode)
        {
            VulnerabilityCode = Guard.Against.NullOrEmpty(vulnerabilityCode, nameof(vulnerabilityCode));
        }
        public void SetCVEId(string cveid)
        {
            CVEId = cveid;
        }
        public void SetTitle(string title)
        {
            Title = Guard.Against.NullOrEmpty(title, nameof(title));
        }
        public void SetSeverity(int severity)
        {
            Severity = Guard.Against.Negative(severity, nameof(severity));
        }
        public void SetCVSS(decimal? cVSS)
        {
            CVSS = cVSS;
        }
        public void SetDetectedDate(DateTime detectedDate)
        {
            DetectedDate = Guard.Against.OutOfSQLDateRange(detectedDate, nameof(detectedDate));
        }
        public void SetResolvedDate(DateTime? resolvedDate)
        {
            ResolvedDate = resolvedDate;
        }
        public void SetRank(int rank)
        {
            Rank = Guard.Against.Negative(rank, nameof(rank));
        }
        public void SetCreatedAt(DateTime createdAt)
        {
            CreatedAt = Guard.Against.OutOfSQLDateRange(createdAt, nameof(createdAt));
        }
        public void SetCreatedBy(Guid createdBy)
        {
            CreatedBy = Guard.Against.Default(createdBy, nameof(createdBy));
        }
        public void SetUpdatedAt(DateTime? updatedAt)
        {
            UpdatedAt = updatedAt;
        }
        public void SetUpdatedBy(Guid? updatedBy)
        {
            UpdatedBy = updatedBy;
        }
        public void SetIsDeleted(bool isDeleted)
        {
            IsDeleted = Guard.Against.Null(isDeleted, nameof(isDeleted));
        }
        
        public void UpdateAssetForVulnerability(Guid newAssetId)
        {
            Guard.Against.Default(newAssetId, nameof(newAssetId));
            if (newAssetId == AssetId)
            {
                return;
            }
            
            AssetId = newAssetId;
            var vulnerabilityUpdatedEvent = new VulnerabilityUpdatedEvent(this, "UpdatedEvent asset");
            Events.Add(vulnerabilityUpdatedEvent);
        }
        
        public virtual Asset Asset { get; private set; }
        
        public Guid AssetId { get; private set; }
        
        private Vulnerability() { }
        
        public Vulnerability(Guid vulnerabilityId, Guid assetId, Guid tenantId, string vulnerabilityCode, string title, int severity, DateTime detectedDate, int rank, DateTime createdAt, Guid createdBy, bool isDeleted)
        {
            this.VulnerabilityId = Guard.Against.Default(vulnerabilityId, nameof(vulnerabilityId));
            this.AssetId = Guard.Against.Default(assetId, nameof(assetId));
            this.TenantId = Guard.Against.Default(tenantId, nameof(tenantId));
            this.VulnerabilityCode = Guard.Against.NullOrEmpty(vulnerabilityCode, nameof(vulnerabilityCode));
            this.Title = Guard.Against.NullOrEmpty(title, nameof(title));
            this.Severity = Guard.Against.Negative(severity, nameof(severity));
            this.DetectedDate = Guard.Against.OutOfSQLDateRange(detectedDate, nameof(detectedDate));
            this.Rank = Guard.Against.Negative(rank, nameof(rank));
            this.CreatedAt = Guard.Against.OutOfSQLDateRange(createdAt, nameof(createdAt));
            this.CreatedBy = Guard.Against.Default(createdBy, nameof(createdBy));
            this.IsDeleted = Guard.Against.Null(isDeleted, nameof(isDeleted));
            
        }
        public override bool Equals(object? obj) =>
        obj is Vulnerability vulnerability && Equals(vulnerability);
        
        public bool Equals(Vulnerability other)
        {
            if (ReferenceEquals(null, other))
            {
                return false;
            }
            
            if (ReferenceEquals(this, other))
            {
                return true;
            }
            
            return VulnerabilityId.Equals(other.VulnerabilityId);
        }
        
        public override int GetHashCode() => VulnerabilityId.GetHashCode();
        
        public static bool operator !=(Vulnerability left, Vulnerability right) => !(left == right);
        
        public static bool operator ==(Vulnerability left, Vulnerability right) => left?.Equals(right) ?? right is null;
        
        private void ValidateInvariants()
        {
            if (string.IsNullOrWhiteSpace(VulnerabilityCode))
            throw new InvalidOperationException("VulnerabilityCode cannot be null or whitespace.");
            if (VulnerabilityCode?.Length > 50)
            throw new InvalidOperationException("VulnerabilityCode cannot exceed 50 characters.");
            if (CVEId?.Length > 50)
            throw new InvalidOperationException("CVEId cannot exceed 50 characters.");
            if (string.IsNullOrWhiteSpace(Title))
            throw new InvalidOperationException("Title cannot be null or whitespace.");
            if (Title?.Length > 500)
            throw new InvalidOperationException("Title cannot exceed 500 characters.");
            if (DetectedDate == default)
            throw new InvalidOperationException("DetectedDate must be set.");
            if (ResolvedDate == default)
            throw new InvalidOperationException("ResolvedDate must be set.");
            if (UpdatedAt == default)
            throw new InvalidOperationException("UpdatedAt must be set.");
        }
        
        private void RaiseDomainEvent(BaseDomainEvent domainEvent)
        {
            Events.Add(domainEvent);
        }
        public static Eff<Validation<string, Vulnerability>> Create(
        Guid vulnerabilityId,
        Guid assetId,
        Guid tenantId,
        string vulnerabilityCode,
        string title,
        int severity,
        DateTime detectedDate,
        int rank,
        DateTime createdAt,
        Guid createdBy,
        bool isDeleted
        )
        {
            return Eff(() => CreateVulnerability(
            vulnerabilityId,
            assetId,
            tenantId,
            vulnerabilityCode,
            title,
            severity,
            detectedDate,
            rank,
            createdAt,
            createdBy,
            isDeleted
            ));
        }
        
        private static Validation<string, Vulnerability> CreateVulnerability(
        Guid vulnerabilityId,
        Guid assetId,
        Guid tenantId,
        string vulnerabilityCode,
        string title,
        int severity,
        DateTime detectedDate,
        int rank,
        DateTime createdAt,
        Guid createdBy,
        bool isDeleted
        )
        {
            try
            {
                var now = DateTime.UtcNow;
                isDeleted = false;
                
                var vulnerability = new Vulnerability
                ( vulnerabilityId,
                assetId,
                tenantId,
                vulnerabilityCode,
                title,
                severity,
                detectedDate,
                rank,
                createdAt,
                createdBy,
                isDeleted)
                ;
                
                return Validation<string, Vulnerability>.Success(vulnerability);
            }
            catch (Exception ex)
            {
                return Validation<string, Vulnerability>.Fail(new Seq<string> { ex.Message });
            }
        }
        public static Eff<Validation<string, Vulnerability>> Update(
        Vulnerability existingVulnerability,
        Guid vulnerabilityId,
        Guid tenantId,
        Guid assetId,
        string vulnerabilityCode,
        string cveid,
        string title,
        int severity,
        decimal? cVSS,
        DateTime detectedDate,
        DateTime? resolvedDate,
        int rank,
        DateTime createdAt,
        Guid createdBy,
        DateTime? updatedAt,
        Guid? updatedBy,
        bool isDeleted
        )
        {
            return Eff(() => UpdateVulnerability(
            existingVulnerability,
            vulnerabilityId,
            tenantId,
            assetId,
            vulnerabilityCode,
            cveid,
            title,
            severity,
            cVSS,
            detectedDate,
            resolvedDate.ToOption().ToNullable(),
            rank,
            createdAt,
            createdBy,
            updatedAt.ToOption().ToNullable(),
            updatedBy.ToOption().ToNullable(),
            isDeleted
            ));
        }
        
        private static Validation<string, Vulnerability> UpdateVulnerability(
        Vulnerability vulnerability,
        Guid vulnerabilityId,
        Guid tenantId,
        Guid assetId,
        string vulnerabilityCode,
        string cveid,
        string title,
        int severity,
        decimal? cVSS,
        DateTime detectedDate,
        DateTime? resolvedDate,
        int rank,
        DateTime createdAt,
        Guid createdBy,
        DateTime? updatedAt,
        Guid? updatedBy,
        bool isDeleted
        )
        {
            try
            {
                
                vulnerability.VulnerabilityId = vulnerabilityId;
                vulnerability.TenantId = tenantId;
                vulnerability.AssetId = assetId;
                vulnerability.VulnerabilityCode = vulnerabilityCode;
                vulnerability.CVEId = cveid;
                vulnerability.Title = title;
                vulnerability.Severity = severity;
                vulnerability.CVSS = cVSS;
                vulnerability.DetectedDate = detectedDate;
                vulnerability.ResolvedDate = resolvedDate;
                vulnerability.Rank = rank;
                vulnerability.CreatedAt = createdAt;
                vulnerability.CreatedBy = createdBy;
                vulnerability.UpdatedAt = updatedAt;
                vulnerability.UpdatedBy = updatedBy;
                vulnerability.IsDeleted = isDeleted;
                vulnerability.RaiseDomainEvent(new VulnerabilityUpdatedEvent(vulnerability, "Updated"));
                
                return Success<string, Vulnerability>(vulnerability);
            }
            catch (Exception ex)
            {
                return Validation<string, Vulnerability>.Fail(new Seq<string> { ex.Message });
            }
        }
        public static class VulnerabilityCalculations
        {
            public static decimal CalculateTotal(int severity, decimal cvss, int rank)
            {
                return severity + cvss + rank;
            }
            
            public static decimal CalculateAverage(int severity, decimal cvss, int rank)
            {
                return (severity + cvss + rank) / 3;
            }
            
            public static decimal CalculateSeverityPerCVSS(int severity, decimal cvss)
            {
                if (cvss == 0)
                throw new DivideByZeroException("Cannot calculate rate: CVSS is zero.");
                return (decimal)severity / cvss;
            }
            
            public static decimal CalculateSeverityPerRank(int severity, int rank)
            {
                if (rank == 0)
                throw new DivideByZeroException("Cannot calculate rate: Rank is zero.");
                return (decimal)severity / rank;
            }
            
            public static decimal CalculateCVSSPerRank(decimal cvss, int rank)
            {
                if (rank == 0)
                throw new DivideByZeroException("Cannot calculate rate: Rank is zero.");
                return (decimal)cvss / rank;
            }
            
            public static int CalculateDaysBetween(DateTime detecteddate, DateTime resolveddate)
            {
                return (resolveddate - detecteddate).Days;
            }
            
        }
    }
}

